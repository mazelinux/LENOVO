C2pbrakf
repo init -b intelCHT_M_MR1_dev -u tablet:/platform/manifest
repo init Cu sma:platform/manifest Cb intelCHT_M_MR1_dev

Q：热插拔。软件+硬件、、。。。。


A：一个完整的热插拔系统包括热插拔系统的硬件，支持热插拔的软件和操作系统，支持热插拔的设备驱动程序和支持热插拔的用户接口。
硬件支持：插入，先数据，后电源；拔出，先电源，后数据
uevent, user space event. 内核与用户空间的一种通信机制

http://www.wowotech.net/linux_kenrel/uevent.html 主要讲述的是头文件
热插拔事件从内核空间到用户空间

/// http://blog.csdn.net/bingqingsuimeng/article/details/7922217 一般，并且知识体系太老了

http://blog.csdn.net/bingqingsuimeng/article/details/7924300  有源代码的讲解，比较清晰

http://www.cnblogs.com/image-eye/archive/2011/08/19/2145858.html 内核启动过程的驱动加载

http://blog.chinaunix.net/uid-25721104-id-3023525.html 讨论的关于热插拔

http://blog.csdn.net/zirconsdu/article/details/8792184 图解很清晰

讲清楚了koject_uevent_env在做了什么，如何进入用户空间
如果定义了"CONFIG_NET”，则使用netlink发送该uevent
其中的call_usermodehelper是个最终切换接口

Uevent模块准备好上报事件的格式后，可以通过两个途径把事件上报到用户空间：一种是通过kmod模块，直接调用用户空间的可执行文件；另一种是通过netlink通信机制，将事件从内核空间传递给用户空间。//这里的kmod是什么鬼？
而在Linux系统，可执行文件的执行，依赖于环境变量，因此kobj_uevent_env用于组织此次事件上报时的环境变量。

软件支持：插入设备->device_add->kobject_uevent->kobject_uevent_env（之前都是内核空间动作）->call_usermodehelper_setup->call_usermodehelper_exec->调用用户空间应用(call_usermodehelper=setup+exec)，

http://blog.chinaunix.net/uid-27666459-id-5747129.html讲解 call_usermodehelper

udevd (udev 后台程序)

1 外设插入
2 总线发现（usb中断hub_irq）新设备，调用device_add;添加新设备到设备管理器
3 device_add调用kobject_uevent(,KOBJ_ADD),向用户空间传递环境变量以及action；netlink方式（广播方式）【主要就是Uevent】
4 用户空间应用程序收到消息【udev ->> udevd】
5 udevd根据消息和环境变量，查询/sys的变化，按照规则(/etc/udev/rules.d/*)，在/dev目录下自动创建设备节点；


同时可以总结，设备插入系统时，相应驱动的关联情况：
① 若直接编译进内核或在启动时加载，则无需在udev中加载驱动模块，在bus_probe_device()中会为其找到相应的驱动；
② 若驱动需要动态加载，则需要在udev(目前的情况是这样，以前也有其他方式如/sbin/hotplug，cardmgr等)中，动态加载其驱动，在驱动的register函数中，找到该device进行关联；

udev 是Linux kernel 2.6系列的设备管理器，它主要的功能是管理/dev目录底下的设备节点的程序。
udevd是根据一定的规则在/dev/目录下生成设备文件的后台服务进程。

比如你插入一个u盘， udevd服务就会自动生成/dev/sda 这样的文件。

http://eeepage.info/sysfs/ 对新的sysfs的讲解非常到位
http://www.linuxidc.com/Linux/2012-05/60757.htm 同样讲解sysfs文件系统
http://blog.chinaunix.net/uid-24227137-id-3266449.html 讲解kobject,kset,sysfs

Q:最小子系统，，，。。。。+ramdisk+initrd

A:
ramdisk是一种基于内存的虚拟文件系统，通常用于放置内核的中间数据。
而initrd全称为"boot loader initialized RAM disk"，也就是由启动加载器所初始化的RamDisk设备，它的作用是完善内核的模块机制，让内核的初始化流程更具弹性；内核以及initrd，都由bootloader在机子启动后被加载至内存的指定位置，主要功能为按需加载模块以及按需改变根文件系统。

initrd 的英文含义是 bootloader initialized RAM disk，就是由 boot loader 初始化的内存盘。
initrd 大体上就是指 包含根文件系统的ramdisk。
initrd即initial ramdisk,它是在系统引导过程中挂载的一个临时根文件系统.激活系统所须加载的文件系统.

http://blog.chinaunix.net/uid-23069658-id-3142047.html  Linux系统启动全过程
http://blog.sina.com.cn/s/blog_c70e10380102w9b5.html     Linux系统启动全过程，详细，方便理解
http://blog.csdn.net/miss_acha/article/details/50004717 讲述的不错关于grub
http://www.2cto.com/os/201603/494064.html后半段讲的很清楚

http://www.ibm.com/developerworks/cn/views/linux/libraryview.jsp?sort_by=&show_abstract=true&show_all=&search_flag=&contentarea_by=Linux&search_by=initrd&topic_by=-1&type_by=%E6%89%80%E6%9C%89%E7%B1%BB%E5%88%AB&ibm-search=%E6%90%9C%E7%B4%A2
IBM提供的文档库里面比较全


先后出现两种机制来作为“boot loader装载kernel”到“真正的/sbin/init执行”这个启动过程的桥梁: initrd和initramfs  

内核在启动的时候，需要加载一些驱动，需要一些内核模块，没有文件系统，就没有文件
文件系统在哪里？在硬盘上实现的，没有硬盘~所以使用ramdisk技术，把内存的一块区域模拟成硬盘使用，initrd将这块“硬盘”初始化，加载必要的文件系统，这个initrd是一个压缩文件系统，里面有一些必要的应用程序以及模块等等，辅助内核完成内核的初始化
initrd基本解压以后就暂时的挂载在根目录下面，然后内核就把他当作根目录来执行一些必要的任务，加载模块等等，后期再将他挂载到一个其他的目录，从而挂载真正的根目录


我的虚拟机里面有解压好的initrd压缩文件

Q：一般什么是.ko
A:
.so 文件是动态链接库文件，相当于 win下的 .dll 文件。
.a  文件是静态库文件。
.ko 是内核模块文件，是内核加载的某个模块，一般是驱动程序。


Q：什么样的设备挂在在paltform上

A:所有的设备都可以挂载在platform上

http://blog.chinaunix.net/uid-25014876-id-111745.html 讲解platform总线的
设备注册的流程

platform_device_register->device_initialize->device_add->setup_parent->kobject_add->device_create_file->device_add_attrs->bus_add_device->kobject_uevent->bus_attach_device
gpio通过platform实现




Q:input_device+*pdevice 关系




Q:
tasklet
schedule
isr
completion关系

A:http://blog.sina.com.cn/s/blog_70a9dd840100uqfh.html 讲述了什么是isr，也涉及了中断上下文以及中断上半部和下半部

http://blog.sina.com.cn/s/blog_65373f1401018w15.html
http://blog.sina.com.cn/s/blog_510ac74901015fgz.html

Q:文件描述符

Q:块设备完成了以后传给谁

Q:设备驱动读出来以后传给谁


Q:设备驱动跑起来的第一个函数是哪一个！
A:module__init

Q:Input子系统架构
A:http://blog.csdn.net/lbmygf/article/details/7360084

Q：MODULE_DEVICE_TABLE是个什么东西？
MODULE_DEVICE_TABLE（设备类型，设备表），其中，设备类型，包括USB,PCI等，也可以自己起名字，上述代码中是针对不同的平台分的类；设备表也是自己定义的，它的最后一项必须是空，用来标识结束。