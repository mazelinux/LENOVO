gpio 怎么在代码里面拉高拉低 gpio chip
设备 驱动
中断 linux驱动如何实现
android 怎么变成ui显示
sd插入 

目的：看懂驱动，改驱动
i2c：传感器；总线下面的设备驱动，
regulator+arm芯片+外设（供电）

##################
tty是伪字符设备驱动

cmd tty
/dev/pts/0

echo "hello world" > /dev/pts/0 会在tty里面显示


##################
主机驱动与外设驱动分离


####################
i2c驱动架构

i2c核心（提供各种api）
###################
/dev目录，设备所对应的文件
/dev/sd* 块设备所对应的文件；对应磁盘上的分区
磁盘以及磁盘上的每一个分区，都对应一个裸的文件
磁盘mount到文件系统
mount 



###################
编译进内核，不编译进内核，编译成模块（img里面）


模块可以接受参数

module_param()把一个模块里面的全局变量定义为对模块的输入，你在加载时候所指定的参数，会修改这个参数
modprobe 加载模块及其依赖模块


模块本身不被编译入内核，控制了内核的大小
模块一旦被加载，与内核中其他部分完全一样
Makefile：一个文本形式的文件，其中包含一些规则告诉make编译哪些文件以及怎样编译这些文件。
Kconfig：一个文本形式的文件，其中主要作用是在内核配置时候，作为配置选项。
.config：文件是在进行内核配置的时候，经过配置后生成的内核编译参考文件。



modinfo xxx.ko
查看模块信息
vermagic 匹配版本


EXPORT_SYMBOL(function)
cat /proc/kallsyms 记录内核里面所有的symbol（上面导出的）



linux kernel 调试方法
printk
dev_xxx
pr_xxx
BUG_ON
BUG




驱动与驱动分离
主机驱动与client驱动分离

######################################################################################################################################3
总线，设备，驱动关系 （驱动和设备要分离，通过总线）
              设备1||驱动1
              设备2||驱动2
                  总线

每一个驱动在注册（insmod）的时候，他会寻找匹配的设备
总线做的最关键的事情就是match；匹配驱动和设备
匹配成功会调用probe函数进行注册

（plaform总线匹配设备和驱动的名字）

热插拔。软件+硬件、、。。。。
最小子系统，，，。。。。+ramdisk+init、、
一般什么是.ko

######################################################################################################################################
kobject kernel对象
kobject 可以看作是所有总线，设备，和驱动的抽象基类；
一个kobject对应sysfs中的一个目录


内核源代码体现了面向对象的思想


所谓驱动层次化 


从面向对象的角度来看：
    - struct kobj（及其相关结构如kset, ktype等）属于最抽象的基类，代码最简洁，最不具体；
    - struct device（及其相关结构如device_driver，device_type等）是对kobj的封装，是第一层派生类；
    - 再上层的结构（如platform_device等），是在struct device的基础上再封装一次，是第二层派生类。

因此，例如我们创建了一个struct platform_device的实例，使用完毕后要释放它。那么这个过程按道理应该是： 
    - 系统内部先调用platform_device的remove函数，它只处理自己层特有的变量； 
    - 完毕后，系统调用第一层派生类struct device的release函数，处理了自己这一层的特有变量； 
    - 最后，调用基类kobject的release函数，将整个空间释放掉。 

整个过程应该会跟C++析构过程比较类似，上述的“系统内部”也应该类似于C++编译器自动生成的代码，因为C++中析构函数的逆向调用是自动进行的，
并没有在派生类的析构函数中显示调用。类似地，在此处上层的release中也不会显式调用下层的release，都是由系统内部完成的。 


什么杨的设备挂在在paltform上
gpio通过platform实现

###################
复杂设备驱动

层次化，结构化，上层不依赖与具体硬件，下层与硬件接口

、proc/interrpet cat
input_device+pdevice 关系

###################
中断上下文；进程上下文
当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称 为该进程的上下文。


上下文context： 上下文简单说来就是一个环境，相对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。
一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。
用户级上下文: 正文、数据、用户堆栈以及共享存储区；
寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；
系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。

最简单的理解：在中断中执行时依赖的环境，就是中断上下文。其他就是进程上下文。

当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文。
当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的上下文，以便在再次执行该进程时，能够必得到切换时的状态执行下去。
在LINUX中，当前进程上下文均保存在进程的任务数据结构中。在发生中断时,内核就在被中断进程的上下文中，在内核态下执行中断服务例程。
但同时会保留所有需要用到的资源，以便中继服务结束时能恢复被中断进程的执行。

http://blog.csdn.net/gangyanliang/article/details/6887128


xxxx你的进程的运行的生命周期
xxxx并发问题
xxxx同步问题

xxxxcompletion 主要作用是用于同步


tasklet
schedule
isr
completion

把进程挂在等待队列e
唤醒等待队列
唤醒进程
schedule（）用于调度的函数，当我进入这个函数，我睡眠了，当这个函数返回时，我又醒来；并且保存状态
######################
等待队列的用法！！！


首先定义等待队列，
添加等待队列
改变进程的状态
调度其他的进程执行
是否被信号唤醒（唤醒则出现错误）
（正常醒来）
将等待队列移除等待队列头
将进程状态改为running

#######################
延时函数

忙等待（cpu空转，消耗cpu）
前提条件：
时间很短，
等的时候不能睡眠，
不然大量消耗cpu资源

睡着延时

#######################
内核定时器
#######################
linux中断底半部机制
Linux中断的顶半部和底半部.：http://blog.csdn.net/zxncvb/article/details/10625181

顶，立即执行完
底，后期执行

Linux新内核不支持中断嵌套

优先级
↓中断上下文
↓软中断上下文
↓进程上下文
#######################
DMA:http://baike.baidu.com/link?url=BANdZFBRDkYkJ4cuLqBiPIIWcn1ScPSx3n0meMHGsnaMVBU6DI6hVIixlFr6LdnSpxt8nW9KEzP3868YJa_LTftFu9Fb5GO8jh1IQuXXdEm
控制内存直接和外设进行数据交互（不去先看cache是否命中相应数据）




cache命中问题 cpu读内存，先看cache是否命中，否则读内存

cpu--cache--内存--dma---外设
1：由于dma不读cache ；会导致cache一致性的问题，cache对应的内存被dma改变，而cpu不知道，出错
2：cpu写入数据到cache；而cache在还没有写入内存的时候，dma接受内存相应位置数据到外设，出错

一致性DMA缓冲区 （即关掉这片内存与cache的关联，cpu也只能直接读取这片内存）
总之想办法忽略掉cache，不去使用他就好

###############################################################################
字符设备驱动
lanana (baidu or google)
$ cat /proc/devices 
查看计算机的设备，字符设备，块设备等
内存拷贝
copy_for_muser
copy_to_user

字符设备驱动主体：file_operations


goto语句在linux编程里大量使用（出错处理的时候大量使用）
kernel/Document里面有编写linux代码规范

#########################
系统io分类
http://shensy.iteye.com/blog/1864781
http://blog.csdn.net/sszgg2006/article/details/38664789

阻塞与非阻塞针对的是进程或线程而同步与异步所针对的是功能函数


阻塞io:进程阻塞在io操作上（读写一个文件，读写一个串口，读写单一设备的时候用法哦）
非阻塞io：防止进程阻塞在io操作上（在单一线程里面服务多个io）
io多路复用：允许同时对多个io进行控制
信号驱动io：一种异步通信模型

一个驱动应该同时支持上面四种io方式


#########################xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
文件描述符：在linux系统中打开文件就会获得文件描述符，它是个很小的正整数。
每个进程在PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针。
 
文件指针：C语言中使用文件指针做为I/O的句柄。
文件指针指向进程用户区中的一个被称为FILE结构的数据结构。
FILE结构包括一个缓冲区和一个文件描述符。
而文件描述符是文件描述符表的一个索引，因此从某种意义上说文件指针就是句柄的句柄（在Windows系统上，文件描述符被称作文件句柄）。

#########################
虚拟文件系统（体现面向对象）

块设备问题

bio：对应来自上层的请求（用户请求）

request：多个bio整合成一个request

一个设备里面有多个request，组成请求队列
请求队列：多个request整合成一个请求队列

电梯调度算法整合这些请求，合并并且排序


文件系统给块设备发一个个请求，丢到一个队列里面；块设备驱动把这一个个请求拿出来处理。

磁盘需要电梯调度
sd卡，flash不需要调度算法


ramdisk ：用内存里面一部分来模拟一个磁盘
loop：把一个img看成一个磁盘
flash：特殊：每一次写都需要先擦除，负载均衡问题。
MTD：

完成了以后传给谁
设备驱动读出来以后传给谁

块设备的主体就是处理上层请求
############################################################################
Platform设备

概括来说，Platform设备包括：基于端口的设备（已不推荐使用，保留下来只为兼容旧设备，legacy）；
连接物理总线的桥设备；集成在SOC平台上面的控制器；连接在其它bus上的设备（很少见）。等等。 

这些设备有一个基本的特征：可以通过CPU bus直接寻址（例如在嵌入式系统常见的“寄存器”）。
因此，由于这个共性，内核在设备模型的基础上（device和device_driver），对这些设备进行了更进一步的封装，抽象出paltform bus、platform device和platform driver，
以便驱动开发人员可以方便的开发这类设备的驱动。 


################################
linux所有的驱动都挂在总线上面（platform总线）

platform 总线
platform driver
platform device
platform data



设备resource（专门描述基地址，中断等等信息）
把跟板子相关的信息，从驱动里面刨除出来


###################################
BSP的组成部分

plat/mach各组建的实现
	内核节拍
	中断管理	
	时钟
	GPIO
	DMA
	io内存映射
设备与资源
	platform device、resource、和platform data
	uart/spi/i2c等设备板级resource



####################################
probe、remove，这两个接口函数用于实现driver逻辑的开始和结束。
Driver是一段软件code，因此会有开始和结束两个代码逻辑，就像PC程序，会有一个main函数，main函数的开始就是开始，return的地方就是结束。
而内核driver却有其特殊性：在设备模型的结构下，只有driver和device同时存在时，才需要开始执行driver的代码逻辑。
这也是probe和remove两个接口名称的由来：检测到了设备和移除了设备（就是为热拔插起的！）。

设备驱动跑起来的第一个函数是哪一个！

############################
3. 设备模型框架下驱动开发的基本步骤
在设备模型框架下，设备驱动的开发是一件很简单的事情，主要包括2个步骤：
步骤1：分配一个struct device类型的变量，填充必要的信息后，把它注册到内核中。
步骤2：分配一个struct device_driver类型的变量，填充必要的信息后，把它注册到内核中。
这两步完成后，内核会在合适的时机，
调用struct device_driver变量中的probe、remove、suspend、resume等回调函数，
从而触发或者终结设备驱动的执行。
而所有的驱动程序逻辑，都会由这些回调函数实现，
此时，驱动开发者眼中便不再有“设备模型”，转而只关心驱动本身的实现。



以上两个步骤的补充说明：
1. 一般情况下，Linux驱动开发很少直接使用device和device_driver，因为内核在它们之上又封装了一层，如soc device、platform device等等，而这些层次提供的接口更为简单、易用（也正是因为这个原因，本文并不会过多涉及device、device_driver等模块的实现细节）。
2. 内核提供很多struct device结构的操作接口（具体可以参考include/linux/device.h和drivers/base/core.c的代码），主要包括初始化（device_initialize）、注册到内核（device_register）、分配存储空间+初始化+注册到内核（device_create）等等，可以根据需要使用。
3. device和device_driver必须具备相同的名称，内核才能完成匹配操作，进而调用device_driver中的相应接口。这里的同名，作用范围是同一个bus下的所有device和device_driver。
4. device和device_driver必须挂载在一个bus之下，该bus可以是实际存在的，也可以是虚拟的。
5. driver开发者可以在struct device变量中，保存描述设备特征的信息，如寻址空间、依赖的GPIOs等，因为device指针会在执行probe等接口时传入，这时driver就可以根据这些信息，执行相应的逻辑操作了。